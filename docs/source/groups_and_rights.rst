权限与用户组
===================================

.. autosummary::
   :toctree: generated

.. role:: python(code)
   :language: python

权限
-----------------

CFMS 的权限由一字符串命名，但有特殊用法规定用户和用户组所属的权限的更加复杂的属性。

用户权限被存贮在 users 表下的 rights 栏中，并符合以下格式：

.. code-block:: python
    :linenos:

    {
        "read": 
            {
                "expire": 0
            },
        ...
    }

它是一个合法的 json 文本，以权限的名称作为键名，对应的键值应当为一个字典，这个字典贮存
描述该权限在该用户上的属性。目前为止，CFMS 仅支持以一个属性对其进行描述：:python:`expire`。

:python:`expire` 描述该权限的过期时间。通过设置为0（或不包含此键），可描述该权限为用户永久拥有。

CFMS 将定期检查并移除过期的权限（还有用户组）。

此外，用户也将从其所在的用户组继承权限。详情请参考 :ref:`usergroup` 一节。 

.. versionadded:: 1.0.0


.. _usergroup:

用户组
----------------------
CFMS 的用户组定义储存在 general.db 下的 groups 表中，由 InitDB() 进行初始化。

目前的默认用户组有： :python:`user`, :python:`sysop` 。 


.. _match_rules:

伪路径权限的匹配规则
----------------------

有时候我们希望指定的权限持有者和用户组能够访问特定的目录或是文档，它们在CFMS中由一个“伪目录表”加以组织；
而这种需求在某些时候可能会显得较为复杂。

所幸的是，CFMS 提供了一套较为全面的匹配机制，这允许用户使用复杂的匹配规则来决定特定文档是否可被请求者访问。

一个匹配规则实际上被作为一个json文本储存。它看起来如下：

.. code-block:: python
   :linenos:

   [ # 列表，并列满足 与 条件
        {
            "match": "any",
            "match_groups": [ # 下级匹配组，满足 any 条件 => True
                {
                    "match": "any",
                    "rights": {
                        "match": "any",
                        "require": ["read"]
                    },
                    "groups": {
                        "match": "any",
                        "require": ["user"]
                    }
                }
            ]
        }, 
        {
            "match": "all",
            "match_groups": [
                {
                    "match": "any",
                    "rights": {
                        "match": "any",
                        "require": []
                    },
                    "groups": {
                        "match": "any",
                        "require": []
                    }
                }
            ]
        }, 
    ]

有些复杂，不是吗？

对用户是否满足规则要求的判断由 Users 类下的 :python:`ifMatchRequirements(self, rules: list)` 进行，它接受一个列表作为要处理的规则。
列表的各个元素都是字典，它们在匹配上是并列关系；出于技术考虑，只有当列表下每个作为元素的字典的要求被满足时该规则才会返回为 True，
即满足与门逻辑。

:python:`ifMatchRequirements()` 将依次检查各个作为最外层列表的元素的字典（我们称之为“首级字典”）所描述的规则是否被满足。在首级字典中，即可以通过改变 "match" 的键值来
确定匹配的规则：它接受 "any" 或 "all" 作为有效值，若出现二者以外的情况则将抛出 :python:`ValueError` 异常。

每个首级字典只接受 "match_groups"（子规则的匹配组）这个列表作为要处理的细化规则。同样地，这个列表下的元素也是字典，具有同样的 match 作为匹配模式，并（与之前不同）
接受两个字典分别作为其 rights 和 groups 的键值。这些字典，同样地，可以使用 match 来确认匹配模式。

若没有给定 match 的值，则将默认以 all 模式进行匹配。

.. warning::
    注意！请不要随意添加没有设置任一所需权限和组的子匹配规则。尽管它们可能看起来是“空”的而被认为
    应该被忽略，但在某些情况下将可能导致整个匹配规则出现意料之外的结果，并可能出现安全性问题。

.. versionchanged:: 1.0.0.20230625_alpha
   现在 :python:`ifMatchRequirements()` 仅接受 rules 作为参数。

.. versionchanged:: 1.0.0.20230628_alpha
   现在 :python:`ifMatchRequirements()` 存在一别名为 :python:`ifMatchRules()`。

我们可以从相对简单的例子开始。

.. code-block:: python
   :linenos:

   [ # 列表，并列满足 与 条件
        {
            "match": "any",
            "match_groups": [ # 下级匹配组，满足 any 条件 => True
                {
                    "match": "any",
                    "rights": {
                        "match": "any",
                        "require": ["read"]
                    },
                    "groups": {
                        "match": "any",
                        "require": []
                    }
                }
            ]
        }
    ]

以上这个示例实际上是最开始提供的示例的其中一部分。我们将它稍作改动，以便更加容易地解释功能：

- 最外层的列表 （:python:`[]`） 容纳着一个字典（当然也可以是多个），这些字典遵循一个相同的格式。
- 这个最外层的字典的 :python:`match` 键被设置为 "any"，这意味着它将在 "match_groups" 下给定的
  多个规则中的任意一个被满足时返回为真。
- 在本例中的 "match_groups" 中的列表下只有一个元素，它也是一个字典，且只能是一个字典：同样地，它
  依然遵照它所被规定的格式被书写。
- 在上一条所述的字典中，有两个键的内容将作为 权限 和 用户组 的匹配规则。我们仅从 "rights" 键来分析：

  1. 与之前相同，它对应的仍然是一个字典。
  2. 它对应的字典也有具有相同功能的 "match" 键。
  3. "require" 对应的是一个列表（至少通常是一个可迭代对象），它包含要匹配的权限。列表中的元素应该
     只是字符串。

上述示例将发挥以下的效用：

检查目标用户是否拥有 :python:`read` 权限，或是否拥有空用户组（groups 键下的字典规定的所需用户组为空）。

如果满足任一条件，则该规则将返回为真。

内部逻辑上，函数将把一个空的列表返回为真。同时，函数也将视 user 用户组为所有人拥有：

.. code-block:: python
   :linenos:

    def hasGroups(self, groups=[]):
        if not groups:
            return True # 没有则返回为真
        for i in groups:
            if i == "user":
                continue # user 用户组跳过
            if not i in self.groups:
                return False
        return True

因此，groups 字典 require 的空列表将在检查时被返回为真，即无论 match 为 any 或 all 时都将返回为真。

为了避免因不设置 groups 而导致有内容的 rights 规则在 any 模式下被忽略（以及不设置 rights 而导致有
内容的 groups 规则被忽略）的情况，函数将在仅设置 rights 和 groups 中的其中之一时将匹配模式调整为 all。

路径权限的匹配规则与附加权限的继承
---------------------------------------------

CFMS 的伪路径同样具有权限的继承关系，并且为了灵活地设置而拥有一套较为复杂的机制。

在开始加以阐释之前，我们对继承原则做如下的规定：

1. 下层路径可以继承上层路径的权限匹配规则，同样的，也可以继承其附加的权限；
2. 上层路径可以选择默认使下级目录不继承该目录的设置；
3. 下层路径在本层级的程度上也可以设置为不继承上层目录的设置；
4. 下层路径的设置服从上层路径的规则设置。例如，如果下层路径选择继承上层路径在某个方面的匹配规则，但上层路径
   的匹配规则字典中的 __subinherit__ 被显式地设置为 :python:`False`，则下层路径最终不会检查请求该特定操作
   的用户是否满足上层规则中所要求的条件（这被实现为在检查上层规则时直接返回 True）。
5. 如果一个目录或文件没有其上级目录（对于一个文件来说，它的上级目录是指它所在的目录，“没有它所在的目录”即代表
   它存在于根目录），我们认为它的上级目录是根目录；
6. 在匹配规则字典中的 "__noinherit__" 键中，存储着不继承上层设置的操作名称。有数个名称被特别设置：
   
   1. "all" - 表示所有的操作；
   2. "deny" - 表示所有的 deny 规则；
   3. "deny\_" - 表示对于特定操作的 deny 规则。

我们将通过几个例子来加以阐释。

假设我们有用户 A 请求读取在目录 `/example/documents/personal/` 下的文件 `a.txt`。这是一个伪路径，我们在此省去
获知伪路径对应的文件（目录）id 的过程，假设这个文件的 id 为 `8fede3`；用户 A 的客户端向服务端请求 `8fede3`。

服务端在收到请求后将做如下的处理：

1. 获取id为 `8fede3` 的文件在数据库中的记录。如果该id并不存在，则服务器将返回响应码 404；
2. 创建一个用户 A 的 `Users` 类对象。通常而言，若请求所附带的 token 能够通过验证，则这个用户应当存在；
3. 调用 :python:`verifyUserAccess()` 函数，并将所请求文件的id、请求对文件的操作、用户对象传入其中。接下来的操作
   交给该函数处理：
   
   1. 判断函数是否由下级目录的同一函数调用（ `_subcall` 是否为真）。在此处，它显然为伪；
   2. 读取文件 `8fede3` 所记录的权限匹配规则（ `access_rules` ），以及其附加权限规则（ `external_access` ）；
   3. 检查该文件是否有上级目录。如果没有，则意味着该文件在根目录下；
   4. 检查用户所请求的操作是否继承上层目录的设置。对于有上级目录的文件而言，:python:`verifyUserAccess()` 将进行
      一次自我调用，将该父级目录的 id 传给该函数；如果其没有上级目录（即其上级目录为根目录），则判断策略 
      `permission_on_rootdir` 中的 `inherit_by_subdirectory` 是否为真。如果为真，则检查用户是否满足根目录的规则要求；
   5. 当在上述自我调用过程中的任何一步中不满足匹配规则的要求时，则该步所在的函数将返回为 False。调用该函数的函数在收
      到该返回值后，也将返回为 False, 直到其回到最初被调用的一级函数为止。但该级函数同样会在收到 False 的结果后返回为
      False。

4. 根据 :python:`verifyUserAccess()` 的结果返回相应的应答。

在第三步中，若对父级规则的判断为真，则该级函数将继续对用户是否满足规则的判断。这一过程实际如下：

1. 判断用户是否满足 deny 所描述的规则，或属于其记录的用户和用户组。如果是，则将直接返回为伪；
2. 在上述判断不为真的情况下，判断用户是否满足 access_rules 中以操作名称为键名的键下所描述的规则。对于这一判断过程，
   请参见 :ref:`match_rules`；
3. 如果不满足，则检查用户及用户所在的组是否在 external_access 下有对应操作的记载（意味着其被授予了执行此种操作的权限）；
4. 如果上述两项都不符合，则返回为 False。


